[
    {
        "question": "In Python, which built-in function can be used to examine the traceback of an exception and provide information about the call stack at the point an error occurred?",
        "options": [
            [
                "A",
                "`traceback.print_exc()`"
            ],
            [
                "B",
                "`sys.debug()`"
            ],
            [
                "C",
                "`inspect.getframe()`"
            ],
            [
                "D",
                "`debugger.show()`"
            ]
        ],
        "answer": "A",
        "index": 1
    },
    {
        "question": "When debugging a Python program, which tool allows you to set breakpoints, step through code, and inspect variables interactively?",
        "options": [
            [
                "A",
                "PyLint"
            ],
            [
                "B",
                "PDB"
            ],
            [
                "C",
                "Pytest"
            ],
            [
                "D",
                "Sphinx"
            ]
        ],
        "answer": "B",
        "index": 2
    },
    {
        "question": "What is a common cause of an \"IndexError\" in Python when working with lists, and how can you identify it during debugging?",
        "options": [
            [
                "A",
                "Attempting to append a value to a non-list variable"
            ],
            [
                "B",
                "Trying to access an index that exceeds the list's length"
            ],
            [
                "C",
                "Using a negative index without checking the list length"
            ],
            [
                "D",
                "Forgetting to initialize the list before accessing it"
            ]
        ],
        "answer": "B",
        "index": 3
    },
    {
        "question": "In Python, what is the purpose of the `assert` statement, and how can it be used effectively in debugging?",
        "options": [
            [
                "A",
                "It is used to handle exceptions in the code."
            ],
            [
                "B",
                "It checks a condition and raises an error if the condition is false, helping catch logical errors."
            ],
            [
                "C",
                "It is a method for logging errors that occur during execution."
            ],
            [
                "D",
                "It is used to optimize performance by skipping unnecessary calculations."
            ]
        ],
        "answer": "B",
        "index": 4
    },
    {
        "question": "Which of the following statements is true regarding the use of logging for debugging in Python?",
        "options": [
            [
                "A",
                "Logging is less effective than using print statements for debugging since it doesn't provide flexibility."
            ],
            [
                "B",
                "The logging level can be configured to filter messages, allowing for more controlled output during debugging."
            ],
            [
                "C",
                "Once set up, logging automatically captures all exceptions without needing to explicitly handle them."
            ],
            [
                "D",
                "Logging is limited to file output and cannot be displayed in the console."
            ]
        ],
        "answer": "B",
        "index": 5
    },
    {
        "question": "In Python, what is the main difference between `print()` debugging and using a debugger tool like `pdb`?",
        "options": [
            [
                "A",
                "`print()` debugging allows you to inspect variable values at any point, while `pdb` only shows variable values after the program has halted."
            ],
            [
                "B",
                "`print()` debugging is non-intrusive and does not change the flow of execution, whereas `pdb` can alter code execution by modifying breakpoints."
            ],
            [
                "C",
                "`print()` debugging requires you to manually add print statements, while `pdb` provides an interactive environment to explore the code dynamically."
            ],
            [
                "D",
                "`print()` debugging is faster than using `pdb`, but provides less information about the program's state."
            ]
        ],
        "answer": "C",
        "index": 6
    },
    {
        "question": "When debugging a Python application, which of the following statements about the `try` and `except` blocks is true?",
        "options": [
            [
                "A",
                "`try` blocks can only contain a single statement, while `except` can handle multiple exceptions."
            ],
            [
                "B",
                "An `except` block can catch exceptions that are not handled in the `try` block, allowing the program to continue execution."
            ],
            [
                "C",
                "You can have multiple `except` blocks to handle different types of exceptions, but they must be in the order of most specific to least specific."
            ],
            [
                "D",
                "If an exception occurs in a `try` block, the program will automatically log the error without needing an `except` block."
            ]
        ],
        "answer": "C",
        "index": 7
    },
    {
        "question": "In Python, what is the purpose of a `finally` block when used in conjunction with `try` and `except`?",
        "options": [
            [
                "A",
                "It ensures that a specific piece of code runs only if an exception is raised in the `try` block."
            ],
            [
                "B",
                "It allows for the re-raising of exceptions caught in the `except` block after executing its code."
            ],
            [
                "C",
                "It guarantees that the code within it will execute regardless of whether an exception was raised or not."
            ],
            [
                "D",
                "It can only be used if the `try` block contains a `return` statement."
            ]
        ],
        "answer": "C",
        "index": 8
    },
    {
        "question": "When using Python's built-in logging module to troubleshoot issues in your application, which logging level should you use for diagnosing issues that are non-critical but may indicate potential future problems?",
        "options": [
            [
                "A",
                "DEBUG"
            ],
            [
                "B",
                "INFO"
            ],
            [
                "C",
                "WARNING"
            ],
            [
                "D",
                "ERROR"
            ]
        ],
        "answer": "C",
        "index": 9
    },
    {
        "question": "In Python, which of the following debugging techniques can help identify memory leaks in a long-running application?",
        "options": [
            [
                "A",
                "Using `print()` statements to track memory usage at various points in your code."
            ],
            [
                "B",
                "Implementing context managers that automatically handle resource allocation and deallocation."
            ],
            [
                "C",
                "Utilizing the `gc` module to monitor and collect garbage during execution."
            ],
            [
                "D",
                "Writing unit tests that explicitly check for memory usage after each function call."
            ]
        ],
        "answer": "C",
        "index": 10
    },
    {
        "question": "In Python, what is the significance of using `breakpoint()` in the context of debugging, and how does it differ from traditional debugging methods?",
        "options": [
            [
                "A",
                "`breakpoint()` is a built-in function that allows you to pause code execution at a specific line, replacing the need for print statements."
            ],
            [
                "B",
                "`breakpoint()` automatically corrects syntax errors in the code before running it."
            ],
            [
                "C",
                "`breakpoint()` only works with the PyCharm IDE and cannot be used in other environments."
            ],
            [
                "D",
                "`breakpoint()` is equivalent to adding `print()` statements and does not allow for interactive debugging."
            ]
        ],
        "answer": "A",
        "index": 11
    },
    {
        "question": "Which of the following exceptions would most likely occur when trying to debug a function that expects a keyword argument but receives a positional argument instead?",
        "options": [
            [
                "A",
                "TypeError"
            ],
            [
                "B",
                "ValueError"
            ],
            [
                "C",
                "KeyError"
            ],
            [
                "D",
                "AttributeError"
            ]
        ],
        "answer": "A",
        "index": 12
    },
    {
        "question": "When using the `pdb` debugger in Python, which command allows you to list the source code around the current line where execution is paused?",
        "options": [
            [
                "A",
                "l (list)"
            ],
            [
                "B",
                "n (next)"
            ],
            [
                "C",
                "s (step)"
            ],
            [
                "D",
                "q (quit)"
            ]
        ],
        "answer": "A",
        "index": 13
    },
    {
        "question": "In a Python script, you encounter a `NameError` when trying to reference a variable. Which of the following debugging strategies is most effective for identifying the cause?",
        "options": [
            [
                "A",
                "Check if there is a typo in the variable name and ensure it is defined before the reference."
            ],
            [
                "B",
                "Use print statements to log all variable names at the start of the script."
            ],
            [
                "C",
                "Comment out the entire block of code to isolate the problem."
            ],
            [
                "D",
                "Run the script in a different Python environment to see if the error persists."
            ]
        ],
        "answer": "A",
        "index": 14
    },
    {
        "question": "In Python, what is the primary purpose of the `logging` module when debugging, and how is it typically configured for maximum effectiveness?",
        "options": [
            [
                "A",
                "To permanently store error messages in a database for retrieval later."
            ],
            [
                "B",
                "To allow detailed level control of output messages, configured through log levels such as DEBUG, INFO, WARNING, ERROR, and CRITICAL."
            ],
            [
                "C",
                "To replace all print statements in the code without the need for additional configuration."
            ],
            [
                "D",
                "To automatically fix syntax errors in the code during runtime."
            ]
        ],
        "answer": "B",
        "index": 15
    },
    {
        "question": "When using the `pdb` module in Python, which command is used to continue execution until the next breakpoint is encountered?",
        "options": [
            [
                "A",
                "`step`"
            ],
            [
                "B",
                "`continue`"
            ],
            [
                "C",
                "`next`"
            ],
            [
                "D",
                "`run`"
            ]
        ],
        "answer": "B",
        "index": 16
    },
    {
        "question": "In Python, which of the following debugging tools can help visualize the call stack and the variables at each level in a graphical interface?",
        "options": [
            [
                "A",
                "`pdb`"
            ],
            [
                "B",
                "`PyCharm Debugger`"
            ],
            [
                "C",
                "`trace`"
            ],
            [
                "D",
                "`pytest`"
            ]
        ],
        "answer": "B",
        "index": 17
    },
    {
        "question": "While debugging, you come across a `TypeError` indicating that a string object is being concatenated with an integer. Which of the following code snippets would best help you identify the source of the problem?",
        "options": [
            [
                "A",
                "`print(type(variable))`"
            ],
            [
                "B",
                "`assert isinstance(variable, str)`"
            ],
            [
                "C",
                "`print(f\"Value: {variable}\")`"
            ],
            [
                "D",
                "`print(\"Debug: \", variable + 5)`"
            ]
        ],
        "answer": "A",
        "index": 18
    },
    {
        "question": "In Python, which of the following statements describes the behavior of the `logging` module when the logging level is set to `WARNING`?",
        "options": [
            [
                "A",
                "Only messages at the `WARNING` level and above will be tracked, ignoring `INFO` and `DEBUG`."
            ],
            [
                "B",
                "It will track all messages including `DEBUG`, `INFO`, `WARNING`, `ERROR`, and `CRITICAL`."
            ],
            [
                "C",
                "It will throw an error if any `DEBUG` messages are attempted to be logged."
            ],
            [
                "D",
                "It will automatically change the logging level to `DEBUG` if any `INFO` messages are logged."
            ]
        ],
        "answer": "A",
        "index": 19
    },
    {
        "question": "When debugging a Python program, which of the following could indicate that an infinite loop is occurring?",
        "options": [
            [
                "A",
                "The program runs faster than expected."
            ],
            [
                "B",
                "The program produces a large amount of output."
            ],
            [
                "C",
                "The program hangs and does not produce any output."
            ],
            [
                "D",
                "The program raises a `MemoryError`."
            ]
        ],
        "answer": "C",
        "index": 20
    },
    {
        "question": "In Python, what debugging technique allows you to temporarily modify a function to output its arguments and return values for better traceability?",
        "options": [
            [
                "A",
                "Monkey Patching"
            ],
            [
                "B",
                "Code Instrumentation"
            ],
            [
                "C",
                "Function Overloading"
            ],
            [
                "D",
                "Decorators"
            ]
        ],
        "answer": "B",
        "index": 21
    },
    {
        "question": "When debugging a Python script, what is the most effective way to analyze the state of a program at each point of execution without modifying the original code?",
        "options": [
            [
                "A",
                "Using print statements liberally throughout the code"
            ],
            [
                "B",
                "Utilizing the built-in `trace` module to log execution flow"
            ],
            [
                "C",
                "Writing unit tests to cover each function"
            ],
            [
                "D",
                "Creating a backup version of the code for trial-and-error"
            ]
        ],
        "answer": "B",
        "index": 22
    },
    {
        "question": "In Python, which scenario is most likely to lead to a `ValueError` during debugging, and how can you catch it effectively?",
        "options": [
            [
                "A",
                "Attempting to convert a non-numeric string to an integer"
            ],
            [
                "B",
                "Accessing an out-of-range index in a tuple"
            ],
            [
                "C",
                "Modifying the contents of a list while iterating over it"
            ],
            [
                "D",
                "Dividing by zero in an arithmetic operation"
            ]
        ],
        "answer": "A",
        "index": 23
    },
    {
        "question": "When using the `pdb` debugger, which command would you use to set a conditional breakpoint that triggers only if a specific condition is met?",
        "options": [
            [
                "A",
                "`break` with a condition"
            ],
            [
                "B",
                "`tbreak`"
            ],
            [
                "C",
                "`condition` followed by the breakpoint number"
            ],
            [
                "D",
                "`watch`"
            ]
        ],
        "answer": "C",
        "index": 24
    },
    {
        "question": "What is the primary benefit of using a context manager in Python for handling resources such as file I/O during debugging?",
        "options": [
            [
                "A",
                "It provides automatic error handling and resource cleanup"
            ],
            [
                "B",
                "It allows the use of global variables without error"
            ],
            [
                "C",
                "It enhances performance during file operations"
            ],
            [
                "D",
                "It simplifies the syntax for exception handling"
            ]
        ],
        "answer": "A",
        "index": 25
    }
]